server {
    listen 8080;
    listen [::]:8080;

    # Explicit stdout/stderr logging (container best practice)
    access_log /dev/stdout;
    error_log /dev/stderr;

    # Load API backend configuration from environment variables
    # Supports multi-instance deployments with custom backend addresses
    set $api_host "ai-resume-api";
    set $api_port "3000";
    set $api_backend "";

    root /usr/share/nginx/html;
    index index.html;

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "no-referrer-when-downgrade" always;
    add_header Content-Security-Policy "default-src 'self' https: data: 'unsafe-inline' 'unsafe-eval';" always;

    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types text/plain text/css text/xml text/javascript application/x-javascript application/xml+rss application/javascript application/json;

    # Cache static assets
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }

    # Health check endpoint (must come before / to avoid bot detection)
    # Used by: container healthcheck, monitoring, load balancers
    location /health {
        access_log off;
        return 200 "healthy\n";
        add_header Content-Type text/plain;
    }

    # Proxy API requests to backend service
    # Uses lua-resty-dns for dynamic DNS resolution that auto-detects /etc/resolv.conf
    # No hardcoded resolver IP needed - works across any Podman network configuration
    location /api/ {

        access_by_lua_block {
            -- 1. Read Environment Variables directly in the active block
            local host = os.getenv("API_BACKEND_HOST") or ngx.var.api_host or "ai-resume-api"
            local port = os.getenv("API_BACKEND_PORT") or ngx.var.api_port or "3000"
            local target_ip = nil

            -- 2. Identify Address Type (IPv6 / IPv4 / Hostname)
            if host:find(":") then
                target_ip = host:find("%[") and host or "[" .. host .. "]"
                ngx.log(ngx.INFO, "Using IPv6: ", target_ip)

            elseif host:match("^%d+%.%d+%.%d+%.%d+$") then
                target_ip = host
                ngx.log(ngx.INFO, "Using IPv4: ", target_ip)

            else
                -- 3. DNS Logic (only if not an IP)
                local cache_key = "dns_" .. host
                target_ip = ngx.shared.dns_cache:get(cache_key)

                if not target_ip then
                    local resty_resolver = require "resty.dns.resolver"
                    local ns_str = ngx.shared.dns_config:get("nameservers") or "127.0.0.11"
                    local nameservers = {}
                    for s in string.gmatch(ns_str, "([^,]+)") do table.insert(nameservers, s) end

                    local r, err = resty_resolver:new{
                        nameservers = nameservers, retrans = 2, timeout = 2000
                    }

                    if not r then
                        ngx.log(ngx.ERR, "Resolver error: ", err)
                        ngx.exit(502)
                    end

                    local answers, err = r:query(host, { qtype = r.TYPE_A })
                    if answers and #answers > 0 then
                        target_ip = answers[1].address
                    else
                        -- Fallback to AAAA
                        answers, err = r:query(host, { qtype = r.TYPE_AAAA })
                        if answers and #answers > 0 then
                            target_ip = "[" .. answers[1].address .. "]"
                        end
                    end

                    if not target_ip then
                        ngx.log(ngx.ERR, "DNS lookup failed for ", host)
                        ngx.exit(502)
                    end
                    ngx.shared.dns_cache:set(cache_key, target_ip, 30)
                end
            end

            -- 4. Set the variable for proxy_pass
            ngx.var.api_backend = "http://" .. target_ip .. ":" .. port
        }

        # Now proxy_pass uses the resolved IP (static, no resolver needed)
        proxy_pass $api_backend;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # SSE streaming support
        proxy_set_header Connection '';
        proxy_buffering off;
        proxy_cache off;
        chunked_transfer_encoding off;

        # Timeouts for long-running streams
        proxy_read_timeout 300s;
        proxy_connect_timeout 10s;
    }

    # SPA routing with bot detection for SEO
    # Note: Specific locations above (/health, /api) are matched first
    location / {
        # Bot detection via Lua (fixes "if is evil" problem)
        access_by_lua_block {
            local user_agent = ngx.var.http_user_agent or ""
            local ua_lower = user_agent:lower()

            -- Check if this is a bot
            if ua_lower:match("bot") or
               ua_lower:match("crawl") or
               ua_lower:match("spider") or
               ua_lower:match("googlebot") or
               ua_lower:match("bingbot") or
               ua_lower:match("yandex") or
               ua_lower:match("linkedinbot") or
               ua_lower:match("twitterbot") or
               ua_lower:match("facebookexternalhit") or
               ua_lower:match("whatsapp") or
               ua_lower:match("slackbot") then
                -- Redirect to SEO handler
                return ngx.exec("@seo")
            end
        }

        # Regular users get React SPA
        try_files $uri $uri/ /index.html;
    }

    # Named location for bot SEO rendering
    location @seo {
        content_by_lua_file /etc/nginx/lua/seo-handler.lua;
    }
}
